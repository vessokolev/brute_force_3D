program brute_force
!
! Brute force method for accommodating N points at the nodes of 3D lattice,
! which represents the most close packing of the points.
!
! NOTE: The algorithm is for demonstration purpose only. It is deliberately left
! unoptimised to show how high the computational cost of the brute force search
! is (even if OpenMP is employed for taking the pair distances).
!
! During its process of execution, this program displays on the screen the
! current value of the exclusion diameter and the number of points accommodated
! so far. The 3D vectors of the points are recored at the end of the program as
! lines of a text file with file name supplied by the variable "file_namefile_name".
!
! Author: Veselin Kolev <vesso.kolev@gmail.com>
! Version: 2017111900
! License: GPLv2/3
!
use iso_c_binding,only:C_INT,C_LONG,C_FLOAT
use mod_random

implicit none

integer(C_INT) :: num_points
integer(C_INT) :: num_points_so_far
integer(C_INT) :: seed
integer(C_INT) :: num_fails
integer(C_INT) :: max_fails
integer(C_INT) :: i
integer(C_INT) :: j
integer(C_INT) :: stat
integer(C_LONG) :: counter
real(C_FLOAT) :: box(3)
real(C_FLOAT) :: r_curr
real(C_FLOAT) :: r_crit
real(C_FLOAT) :: factor
real(C_FLOAT),allocatable :: coord(:,:)
character(len=4096) :: file_name
!
file_name='points.txt'
factor=0.9999
max_fails=10000
seed=23280
!
box=(/100.0_C_FLOAT,100.0_C_FLOAT,100.0_C_FLOAT/)
num_points=50
r_crit=6.0_C_FLOAT
!
r_curr=minval(box)/2
!
if (r_curr<=r_crit) then
   print *
   print *,'ERROR: The initial value of the exclusion diameter is equal or greater then the target one!'
   print *
   call exit(1)
end if
!
! Allocate the array for storing the coordinates of the points:
!
allocate(coord(3,num_points))
!
! and set them all zeros:
!
coord=0.0_C_FLOAT
!
stat=0
!
r_crit=r_crit**2
r_curr=r_curr**2
factor=factor**2
!
! Initialize the Mersenne Twister random number generator
!
call init_genrand(seed)
!
num_points_so_far=0
!
num_fails=10000
! 
do while(.true.)
   !
   ! Try to add a new point to the system by proposing its coordinates,
   ! generated by calling the Mersenne Twisert RNG:
   !
   num_points_so_far=num_points_so_far+1
   !
   coord(:,num_points_so_far)=(/genrand_real2(),genrand_real2(),genrand_real2()/)*box
   !
   !
   ! We need one boolean variable to help establishing whether a newly introduced
   ! point is in collision with some other points, without exiting the loop
   ! prematurely (which might be a standard programming trick in C and Fortran
   ! serial code, but does not support the parallelization). The variables used
   ! bellow (counter) supports OpenMP reduction.
   !
   counter=0
   !
!$OMP PARALLEL DO REDUCTION(+:counter)
   do i=1,num_points_so_far-1
      do j=i+1,num_points_so_far
         if (norm03(coord,i,j,box)<r_curr) then
            counter=counter+1
         end if
      end do
   end do
!$OMP END PARALLEL DO
   !
   if (counter>0_C_LONG) then
      !
      ! If the proposed point collides with some of the points already
      ! introduced, skip that proposal by reducing the number of the points by
      ! one.
      !
      num_fails=num_fails+1
      num_points_so_far=num_points_so_far-1
   else
      !
      ! Nullify the variable that counts the number of subsequent fails to
      ! accommodate a point. We already added a new point!
      !
      num_fails=0
   end if
   !
   if (num_points_so_far==num_points) then
      !
      ! If the requested number of points is already accommodated in the box,
      ! stop the execution of the algorithm:
      !
      exit
   end if
   !
   if (num_fails==max_fails) then
      !
      ! If the search for a vacant position available for accommodating a new
      ! point is failed, then shring the exclusion diameter by factor of
      ! "factor":
      !
      r_curr=r_curr*factor
      if (r_curr<r_crit) then
         !
         ! If the newly proposed exclusion diameter is less than the minimum one
         ! allowed, stop the execution of the algorithm, and return the status
         ! of the problem as value of "stat":
         !
         stat=1
         exit
      end if
      !
      ! Nullify the counter that counts the number of subsequent fails to
      ! accommodate a new point. That allows the algorithm to find more free
      ! space for accommodating the new points.
      !
      num_fails=0
      print *,sqrt(r_curr),num_points_so_far
   end if

end do
!
! Write down the derived coordinates of the points as a text file:
!
open(unit=666,file=file_name,status='unknown')
!
do i=1,num_points_so_far
   write(unit=666,fmt='(E12.5,1x,E12.5,1x,E12.5)') coord(1,i),coord(2,i),coord(3,i)
end do
!
close(unit=666)
!
deallocate(coord)
!
! Rise some error message in case stat!=0:
!
if (stat/=0) then
   print *
   print *,'WARNING: Only ',num_points_so_far,' points out of ',&
           num_points,' has been found. Adjust he starting parameters!'
   print *
   call exit(1)
end if
!
call exit(0)
!
contains


function norm03(coord,i,j,box) result(res)
!
! Computes the paid distance between i-th and j-th points in Cartesian
! coordinates, by using periodic boundary conditions (PBC). Note that the
! result is the square and not the square root of that distance, since
! the part of the code invoking this function can deal with it.
!
! Interface variables:
!
real(C_FLOAT),intent(in)  :: coord(:,:)
integer(C_INT),intent(in) :: i
integer(C_INT),intent(in) :: j
real(C_FLOAT),intent(in)  :: box(3)
real(C_FLOAT) :: res
!
! Local variables:
!
real(C_FLOAT) :: dummy(3)

dummy=coord(:,i)-coord(:,j)
dummy=abs(dummy-box*nint(dummy/box))

res=sum(dummy(:)**2)

end function norm03


end program brute_force
